/**
 * TicTacToe
 * 08/11/2021
 * ST0486 Programmazione 2021/22
 * Università degli Studi di Camerino - Informatica/Informatica per la comunicazione digitale
 */

/*
 * Quale informazione dobbiamo rappresentare? Lo schema del TTT
 * Come la rappresentiamo?
 * 	- Usiamo una matrice di dimensione 3x3
 * 	- Usiamo lo 0 per rappresentare una cella vuota, 1 rappresenta la X, 2 rappresenta il cerchio
 * Di quali operazioni abbiamo bisogno?
 * 	- Operazioni di input
 * 		- scrivere un metodo che preso in input l'intero del giocatore corrente e lo schema
 * 		  chiede in input riga e colonna dove inserire la pedina
 * 	- Controllo della vittoria
 * 		- Scrivere un metodo che preso in input verifica se c'è un vincitore e restituisce un
 * 		  intero che indica il risultato
 * 	- Controllo della validità di una mossa
 * 		- Scrivere un metodo che preso in input lo schema e gli interi che rappresentano riga e colonna
 * 		  restituisce true o false se la posizione è valida o meno 
 * 	- Costruire lo schema
 * 		- Scrivere un metodo che non prende parametri e restituisce un nuovo schema
 * 	- Operazioni di output
 * 		- Scrivere un metodo che preso in input uno schema lo stampa a console
 * 	- Alternare il turno di gioco
 * 		- Scrivere un metodo che continua a chiedere la mossa ai due giocatori fino a quanto
 * 		  la partita non è terminata o con una vittoria o con la patta
 */

int[][] creaSchema() {
	int[][] schema = new int[][] {
		{0, 0, 0},
		{0, 0, 0},
		{0, 0, 0}
	};
	return schema;
}

char ottieniSimbolo(int v) {
	switch (v) {
		case 1: return 'X';
		case 2: return 'O';
		default: return ' ';
	}
}

void stampaRiga(int[] riga) {
	System.out.println(" " + ottieniSimbolo(riga[0]) + " | " + ottieniSimbolo(riga[1]) + " | " + ottieniSimbolo(riga[2]));
}

void stampaSeparatore() {
	System.out.println("---+---+---");
}

void stampaSchema(int[][] schema) {
	stampaRiga(schema[0]);
	stampaSeparatore();
	stampaRiga(schema[1]);
	stampaSeparatore();
	stampaRiga(schema[2]);
}

boolean mossaValida(int[][] schema, int r, int c) {
	return schema[r][c] == 0;
}

// Restituiamo: 1 se vince 1, 2 se vince 2, 0 se c'è qualcosa di libero, -1 se tutto pieno
int risultatoElemento(int[][] schema, int r, int c, int dr, int dc) {
	int risultato = 1;
	for(int i = 0; i < 3; i++) {
		risultato *= schema[r + i * dr][c + i * dc];
	}
	if((risultato != 0) || (risultato != 1) || risultato != 8) {
		return -1;
	} else {
		return risultato;
	}
}

int combina(int r1, int r2) {
	if((r1 == 1) || (r2 == 1)) return 1;
	if((r1 == 8) || (r2 == 8)) return 8;
	if((r1 == -1) && (r2 == -1)) return -1;
	return 0;
}

int decodificaValore(int risultato) {
	if(risultato == 8) {
		return -1;
	} else {
		return 0;
	}
}

int risultato(int[][] schema) {
	int risultato = 0;
	for(int i = 0; i<3; i++) {
		risultato = combina(risultato, risultatoElemento(schema, i, 0, 0, 1));
		risultato = combina(risultato, risultatoElemento(schema, 0, i, 1, 0));
	}
	risultato = combina(risultato, risultatoElemento(schema, 0, 0, 1, 1));
	risultato = combina(risultato, risultatoElemento(schema, 2, 0, -1, 1));
	return decodificaValore(risultato);
}

int leggiValore(String elemento, int giocatore) {
	while(true) {
		int valore = Input.getInt("In quale " + elemento + "vuoi posizionare la " + ottieniSimbolo(giocatore) + "?");
		if((valore > 0) && (valore < 4)) {
			return valore -1;
		}
		System.out.println("Errore! Inserire un valore tra 0 e 2!");
	}
}

/**
 * Legge da input la mossa del giocatore passato come argomento
 * e restituisce le coordinate scelte in un array di due elementi.
 * 
 * @param indice giocatore (1 o 2)
 * @return un array di due elementi con le coordinate selezionate
 */
int[] leggiMossa(int giocatore) {
	int[] posizione = new int[2];
	posizione[0] = leggiValore("riga", giocatore);
	posizione[1] = leggiValore("colonna", giocatore);
	return posizione;
}

int[][] schema = creaSchema();
stampaSchema(schema);